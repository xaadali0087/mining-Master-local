import { useState, useEffect } from "react";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import { useExpeditions } from "@/hooks/useExpeditions";
import { useStaking } from "@/hooks/useStaking";
import { ethers } from "ethers";
import { useRoninWallet } from "@/services/wallet/RoninWalletProvider";
import { getContractAddress } from "@/config/contracts";

interface MiningRewards {
  gems: number;
}

interface MiningResult {
  success: boolean;
  rewards: MiningRewards;
}

export default function ReturnFromMines() {
  const [showResults, setShowResults] = useState(false);
  const [miningResults, setMiningResults] = useState<MiningResult | null>(null);
  const [isCompletingExpedition, setIsCompletingExpedition] = useState(false);

  const { connector } = useRoninWallet();
  const { readyToComplete, refetch, statuses } = useExpeditions(15000);
  const { stakedMiners } = useStaking();
  
  // Log detailed information about expedition status for debugging
  useEffect(() => {
    console.log(`[ReturnFromMines] Debug info:`, {
      readyToComplete: readyToComplete.length,
      stakedMiners: stakedMiners.length,
      isCompletingExpedition,
      expeditionStatuses: statuses.map((s: any) => ({
        minerId: s.minerId,
        onExpedition: s.onExpedition,
        startTime: s.startTime,
        endTime: s.endTime,
        completed: s.completed,
        currentTime: Math.floor(Date.now() / 1000),
        timeRemaining: s.endTime > Math.floor(Date.now() / 1000) ? 
                      s.endTime - Math.floor(Date.now() / 1000) : 
                      "Time elapsed"
      }))
    });
  }, [readyToComplete, stakedMiners, statuses, isCompletingExpedition]);
  
  // Consider miners ready if ANY are ready to complete, rather than requiring all
  const anyReady = readyToComplete.length > 0;
  // We no longer require all miners to be ready, just at least one
  const miningComplete = anyReady;
  
  // Enhanced debug logging for expeditions ready to complete
  useEffect(() => {
    if (anyReady && connector) {
      console.log('[ReturnFromMines] Miners ready to complete expedition:', readyToComplete.map((m: any) => m.minerId));
    }
  // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [anyReady, connector, readyToComplete]);

  // Separate the internal expedition completion logic from the UI button handler
  const handleReturnInternal = async () => {
    try {
      const provider = new ethers.BrowserProvider(connector!.provider);
      const signer = await provider.getSigner();
      const connectedAddress = await signer.getAddress();
      
      const expAddress = getContractAddress('MiningExpeditionProxy');
      const stakingAddress = getContractAddress('StakingProxy');
      if (!expAddress) throw new Error('Missing expedition proxy address');
      if (!stakingAddress) throw new Error('Missing staking proxy address');
      
      // ABIs for both contracts
      const expeditionAbi = [
        'function completeExpeditions(uint256[])',
        'function expeditions(uint256) view returns (uint256,uint256,bool,bool,uint256,uint256,uint256)',
        'function MINING_COOLDOWN() view returns (uint256)'
      ];
      const stakingAbi = [
        'function stakedMiners(uint256) view returns (address,uint8,bool)'
      ];
      
      const expedition = new ethers.Contract(expAddress, expeditionAbi, signer);
      const staking = new ethers.Contract(stakingAddress, stakingAbi, provider);
      
      // Check blockchain time for diagnostics
      const blockNumber = await provider.getBlockNumber();
      const block = await provider.getBlock(blockNumber);
      const blockchainTime = block?.timestamp || Math.floor(Date.now() / 1000);
      const localTime = Math.floor(Date.now() / 1000);
      console.log(`[ReturnFromMines] Time diagnostics:`, {
        blockchainTime,
        localTime,
        diff: localTime - blockchainTime,
        blockNumber
      });
      
      // Get current expedition time setting
      const cooldownTime = await expedition.MINING_COOLDOWN();
      console.log(`[ReturnFromMines] Current expedition duration setting: ${cooldownTime} seconds`);

      // Get potential miners to complete
      const potentialMinerIds = readyToComplete.map(({ minerId }: { minerId: number }) => minerId);
      console.log(`[ReturnFromMines] Checking ownership for miners:`, potentialMinerIds);
      
      // Verify ownership of each miner
      const ownedMinerIds: number[] = [];
      const unownedMinerIds: number[] = [];
      
      for (const minerId of potentialMinerIds) {
        try {
          const [owner, , isStaked] = await staking.stakedMiners(minerId);
          if (isStaked && owner.toLowerCase() === connectedAddress.toLowerCase()) {
            ownedMinerIds.push(minerId);
          } else {
            unownedMinerIds.push(minerId);
            console.log(`[ReturnFromMines] Miner ${minerId} not owned by connected wallet (owner: ${owner})`);
          }
        } catch (err) {
          console.warn(`[ReturnFromMines] Error checking ownership for miner ${minerId}:`, err);
          unownedMinerIds.push(minerId);
        }
      }
      
      // Check if we have any owned miners to complete
      if (ownedMinerIds.length === 0) {
        throw new Error(`No owned miners ready for expedition completion. Please connect with the wallet that owns the miners.`);
      }
      
      // If some miners are unowned, show a warning but proceed with owned ones
      if (unownedMinerIds.length > 0) {
        console.warn(`[ReturnFromMines] Skipping ${unownedMinerIds.length} miners not owned by connected wallet`);
      }
      
      console.log(`[ReturnFromMines] Attempting to complete expeditions for owned miners:`, ownedMinerIds);
      
      // Initialize miners that are truly ready according to blockchain time
      let validatedMinerIds: number[] = [];
      
      // Validate each miner's expedition against blockchain time
      try {
        const actuallyReadyMiners: number[] = [];
        const notReadyMiners: {minerId: number, reason: string}[] = [];
        const latestBlock = await provider.getBlock('latest');
        const latestBlockchainTime = latestBlock?.timestamp || Math.floor(Date.now() / 1000);

        for (const id of ownedMinerIds) {
          try {
            const expeditionData = await expedition.expeditions(id);
            const startTime = Number(expeditionData[0]);
            const endTime = Number(expeditionData[1]);
            const completed = expeditionData[2];
            const successful = expeditionData[3];
            
            console.log(`[ReturnFromMines] Miner ${id} expedition data:`, {
              startTime,
              endTime,
              completed,
              successful,
              blockchainTime: latestBlockchainTime,
              readyStatus: latestBlockchainTime >= endTime ? 'READY' : `NOT READY (${endTime - latestBlockchainTime}s remaining)`,
              startedStatus: startTime > 0 ? 'STARTED' : 'NOT STARTED'
            });

            // Verify if this miner is actually ready according to blockchain time
            if (startTime > 0 && !completed && latestBlockchainTime >= endTime) {
              actuallyReadyMiners.push(id);
            } else {
              let reason = 'Unknown';
              if (startTime === 0) reason = 'Expedition not started';
              else if (completed) reason = 'Already completed';
              else if (latestBlockchainTime < endTime) reason = `Time remaining: ${endTime - latestBlockchainTime}s`;
              notReadyMiners.push({minerId: id, reason});
            }
          } catch (err) {
            console.warn(`[ReturnFromMines] Error checking expedition data for miner ${id}:`, err);
            notReadyMiners.push({minerId: id, reason: 'Error checking data'});
          }
        }

        // Report on our findings
        if (actuallyReadyMiners.length === 0) {
          console.warn('[ReturnFromMines] No miners are actually ready according to blockchain time!');
          console.warn('[ReturnFromMines] Not ready miners:', notReadyMiners);
          throw new Error('No miners are ready for expedition completion according to blockchain time.');
        } else if (notReadyMiners.length > 0) {
          console.warn(`[ReturnFromMines] ${notReadyMiners.length} miners not ready, proceeding with ${actuallyReadyMiners.length} ready miners`);
          console.warn('[ReturnFromMines] Not ready miners:', notReadyMiners);
        }
        
        // Update validated miners list with those truly ready according to blockchain time
        validatedMinerIds = actuallyReadyMiners;
      } catch (error) {
        console.warn('[ReturnFromMines] Error validating expedition readiness:', error);
        throw error;
      }
      
      // Use the validated miners list that meets blockchain time requirements
      if (validatedMinerIds.length === 0) {
        throw new Error('No miners are ready for expedition completion according to blockchain time');
      }
      
      console.log(`[ReturnFromMines] Calling completeExpeditions with validated IDs:`, validatedMinerIds);
      
      let tx;
      
      // Try/catch with detailed diagnostics
      try {
        tx = await expedition.completeExpeditions(validatedMinerIds);
      } catch (err: any) {
        console.error(`[ReturnFromMines] Initial tx failed:`, err);
        
        // Check if we got a specific error message
        if (err.reason) {
          console.error(`[ReturnFromMines] Error reason: ${err.reason}`);
          throw new Error(`Transaction failed: ${err.reason}`);
        }
        
        // Try with manual gas limit as fallback
        if (err.action === 'estimateGas') {
          console.log(`[ReturnFromMines] Retrying with manual gas limit...`);
          try {
            // Add more gas to ensure completion
            const gasEstimate = 500_000 * validatedMinerIds.length;
            console.log(`[ReturnFromMines] Using gas limit of ${gasEstimate}`);
            tx = await expedition.completeExpeditions(validatedMinerIds, { gasLimit: gasEstimate });
          } catch (gasErr: any) {
            console.error(`[ReturnFromMines] Manual gas limit attempt failed:`, gasErr);
            if (gasErr.reason) {
              throw new Error(`Transaction with manual gas failed: ${gasErr.reason}`);
            }
            throw gasErr;
          }
        } else {
          throw err;
        }
      }
      
      // Wait with clear logging
      console.log(`[ReturnFromMines] Transaction sent, waiting for confirmation...`);
      const receipt = await tx.wait();
      console.log(`[ReturnFromMines] Transaction confirmed! Hash: ${receipt.hash}`);
      
      // Aggregate rewards via view calls
      const responses = await Promise.all(validatedMinerIds.map((id: number) => expedition.expeditions(id)));
      const totalGems = responses.reduce((sum: number, res: any) => res.successful ? sum + Number(res.boostedReward) / 1e18 : sum, 0);
      const anySuccess = responses.some((res: any) => res.successful);
      
      setMiningResults({ success: anySuccess, rewards: { gems: totalGems } });
      setShowResults(true);
      
      // refresh statuses
      refetch();
      return true; // Success
    } catch (e) {
      console.error('[ReturnFromMines] Complete expedition error:', e);
      
      // Provide more helpful error messages based on error type
      const errorMsg = (e as any).message || 'Unknown error';
      
      if (errorMsg.includes('Unauthorized') || errorMsg.includes('Not the staked miner owner')) {
        alert('Failed to complete expedition: You are not authorized to complete expeditions for these miners. Please connect with the wallet that owns the miners.');
      } 
      else if (errorMsg.includes('Expedition not yet ended') || errorMsg.includes('blockchain time')) {
        alert('Failed to complete expedition: The expedition has not ended yet according to blockchain time. Please wait until the expedition is complete.');
      }
      else if (errorMsg.includes('Miner not on expedition')) {
        alert('Failed to complete expedition: One or more miners are not on an expedition or have already completed their expedition.');
      }
      else {
        alert('Failed to complete expedition: ' + errorMsg);
      }
      
      return false; // Failed
    } finally {
      setIsCompletingExpedition(false);
    }
  };
  
  // UI button handler - only triggered by user action
  const handleReturn = () => {
    if (!connector) {
      alert('Wallet not connected. Please connect your wallet and try again.');
      return;
    }
    
    if (!anyReady) {
      console.log('[ReturnFromMines] No miners are ready to complete expedition:', {
        readyToComplete: readyToComplete.map((m: any) => m.minerId),
        statuses: statuses.map((s: any) => ({
          minerId: s.minerId,
          onExpedition: s.onExpedition,
          endTime: s.endTime,
          currentTime: Math.floor(Date.now() / 1000),
          timeLeft: s.endTime - Math.floor(Date.now() / 1000),
          completed: s.completed
        }))
      });
      
      alert('No miners have completed their expedition yet. Please wait until expedition time is finished.');
      return;
    }
    
    // Mark as processing and call the internal handler
    setIsCompletingExpedition(true);
    console.log('[ReturnFromMines] User initiated expedition completion');
    handleReturnInternal();
  };

  const closeResults = () => {
    setShowResults(false);
    setMiningResults(null);
    refetch();
  };

  return (
    <div className="flex justify-center w-full">
      <button
        onClick={handleReturn}
        disabled={!miningComplete || isCompletingExpedition}
        className={`w-full ${miningComplete && !isCompletingExpedition ? 'bg-amber-500 hover:bg-amber-600' : 'bg-amber-500/60 cursor-not-allowed'} text-black font-semibold p-3 rounded-lg transition-all duration-300 font-winky`}
        data-component-name="ReturnFromMines"
      >
        {isCompletingExpedition ? 'Returning from Mines...' : 'Return From The Mines'}
      </button>

      <Dialog open={showResults} onOpenChange={setShowResults}>
        <DialogContent className="bg-[#2a1a0a] border-2 border-amber-500/30 rounded-xl p-8 !max-w-2xl">
          <DialogHeader className="flex justify-between items-center mb-6">
            <DialogTitle className="text-2xl font-bold text-amber-400 font-winky">
              {miningResults?.success ? "Mining Success!" : "Mining Failed!"}
            </DialogTitle>
          </DialogHeader>

          <div className="bg-[#1a0d00] border border-amber-500/20 rounded-lg p-6 mb-6">
            {miningResults?.success ? (
              <div className="text-center">
                <p className="text-green-400 text-xl mb-4 font-winky">
                  Your miners found gems!
                </p>
                <div className="bg-[#2a1a0a] p-4 rounded-lg inline-block">
                  <p className="text-amber-300 font-winky text-lg">Gems</p>
                  <p className="text-blue-400 text-2xl font-bold mt-2">
                    {miningResults.rewards.gems.toFixed(2)}
                  </p>
                </div>
              </div>
            ) : (
              <div className="text-center">
                <p className="text-red-400 text-xl mb-4 font-winky">
                  Your miners came back empty-handed!
                </p>
              </div>
            )}
          </div>

          <div className="flex justify-center">
            <button
              onClick={closeResults}
              className="bg-amber-500 hover:bg-amber-600 text-black font-semibold px-6 py-3 rounded-lg transition-all duration-300 font-winky"
            >
              Collect Rewards
            </button>
          </div>
        </DialogContent>
      </Dialog>
    </div>
  );
}
